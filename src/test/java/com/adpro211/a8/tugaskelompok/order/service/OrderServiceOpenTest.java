package com.adpro211.a8.tugaskelompok.order.service;

import com.adpro211.a8.tugaskelompok.auths.models.account.Buyer;
import com.adpro211.a8.tugaskelompok.auths.models.account.Seller;
import com.adpro211.a8.tugaskelompok.auths.repository.AccountRepository;
import com.adpro211.a8.tugaskelompok.auths.service.AccountServiceImpl;
import com.adpro211.a8.tugaskelompok.order.model.order.Order;
import com.adpro211.a8.tugaskelompok.order.model.item.Item;
import com.adpro211.a8.tugaskelompok.order.model.states.*;
import com.adpro211.a8.tugaskelompok.order.repository.ItemRepository;
import com.adpro211.a8.tugaskelompok.order.repository.OrderRepository;
import com.adpro211.a8.tugaskelompok.product.model.Product;
import com.adpro211.a8.tugaskelompok.wallet.models.Wallet;
import com.adpro211.a8.tugaskelompok.wallet.repository.TransactionRepository;
import com.adpro211.a8.tugaskelompok.wallet.repository.WalletRepository;
import com.adpro211.a8.tugaskelompok.wallet.service.WalletServiceImpl;

import java.util.List;
import java.util.ArrayList;
import java.time.LocalDateTime;

import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static org.mockito.Mockito.times;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.web.server.ResponseStatusException;

@ExtendWith(MockitoExtension.class)
public class OrderServiceOpenTest {

    @InjectMocks
    OrderServiceImpl orderService;

    @Mock
    OrderRepository orderRepository;

    @Mock
    ItemRepository itemRepository;

    @Mock
    AccountRepository accountRepository;

    @Mock
    TransactionRepository transactionRepository;

    @Mock
    Buyer mockBuyer;

    @Mock
    Seller mockSeller;

    @Mock
    AccountServiceImpl accountService;

    @Mock
    WalletRepository walletRepository;

    @Mock
    WalletServiceImpl walletService;

    private Order order;
    private Item item;
    private OrderState state;
    private Buyer buyer;
    private Seller seller;
    private Product product;
    private Wallet walletBuyer;
    private Wallet walletSeller;
    private LocalDateTime orderTime;
    private Iterable<Item> itemsIterable;

    @BeforeEach
    void setUp() {

        seller = new Seller();
        seller.setName("umji");
        seller.setId(1);
        seller.setEmail("yewonkim@gmail.com");
        seller.setAccountType("seller");

        buyer = new Buyer();
        buyer.setName("pembeli");
        buyer.setId(2);
        buyer.setEmail("ajib@gmail.com");
        buyer.setAccountType("buyer");
        buyer.setAlamat("menuju jalan lurusmu ya Allah");

        accountRepository.save(buyer);
        accountRepository.save(seller);

        walletBuyer = new Wallet();
        walletBuyer.setId(5);
        walletBuyer.setAccount(buyer);
        walletBuyer.setBalance(200000.0);
        buyer.setWallet(walletBuyer);

        walletSeller = new Wallet();
        walletSeller.setId(6);
        walletSeller.setAccount(seller);
        walletSeller.setBalance(100000.0);
        seller.setWallet(walletSeller);

        product = new Product();
        product.setId(3);
        product.setName("mie");
        product.setPrice(1000);
        product.setStock(50);
        product.setDescription("maknyusss");
        product.setImageUrl("https://google.com");
        product.setOwnerAccount(seller);

        item = new Item();
        item.setId(3);
        item.setName(product.getName());
        item.setOrder(order);
        item.setQuantity(2);
        item.setPrice(product.getPrice() * item.getQuantity());
        item.setProduct(product);

        state = new OpenState();

        order = new Order();
        order.setId(1);
        order.setPaymentReceived(false);
        order.setBuyer(buyer);
        order.setSeller(seller);
        order.setStatus(state.getStateDescription());
        orderTime = LocalDateTime.now();
        order.setOrderTime(orderTime);

        List<Item> itemList = new ArrayList<Item>();
        itemList.add(item);
        order.setItems(itemList);
        order.setTotalPrice(order.getTotalPrice() + item.getPrice());
        itemsIterable = itemList;
    }

    @Test
    void testCreateOrderSuccess() {
        lenient().when(accountService.getAccountById(2)).thenReturn(this.seller);
        orderService.createOrder(buyer, 2);
        verify(orderRepository, times(1)).save(any());
        assertEquals(orderTime, order.getOrderTime());
    }

    @Test
    void testCreateOrderButSellerIsNull() {
        lenient().when(accountService.getAccountById(2)).thenThrow(new NullPointerException());
        Throwable exception = assertThrows(ResponseStatusException.class, () -> orderService.createOrder(buyer, 2));
        assertEquals("400 BAD_REQUEST \"Seller doesn't exist\"", exception.getMessage());
        verify(orderRepository, times(0)).save(any());
    }

    @Test
    void testCreateOrderThrowsException() {
        lenient().when(orderRepository.save(any()))
                .thenThrow(new DataIntegrityViolationException("This order already exist"));
        Throwable exception = assertThrows(ResponseStatusException.class, () -> orderService.createOrder(buyer, 2));
        assertEquals("400 BAD_REQUEST \"This order already exist\"", exception.getMessage());
    }

    @Test
    void testGetOrderByIdSuccess() {
        lenient().when(orderRepository.findOrderById(1)).thenReturn(order);
        assertEquals(order, orderService.getOrderById(1));
    }

    @Test
    void testGetOrdersBySellerSuccess() {
        List<Order> listOrder = new ArrayList<Order>();
        listOrder.add(order);
        lenient().when(orderRepository.findAllBySeller(seller)).thenReturn(listOrder);
        assertEquals(listOrder, orderService.getOrdersBySeller(seller));
    }

    @Test
    void testGetOrdersByBuyerSuccess() {
        List<Order> listOrder = new ArrayList<Order>();
        listOrder.add(order);
        lenient().when(orderRepository.findAllByBuyer(buyer)).thenReturn(listOrder);
        assertEquals(listOrder, orderService.getOrdersByBuyer(buyer));
    }

    @Test
    void testCreateItemSuccess() {
        lenient().when(orderRepository.findOrderById(1)).thenReturn(order);
        orderService.createItem("mie", 2, 1, product);
        assertEquals(2, order.getItems().size());
        verify(itemRepository, times(1)).save(any());
    }

    @Test
    void testCreateItemSuccessWhenOrderItemsIsEmpty() {
        order.setItems(null);
        lenient().when(orderRepository.findOrderById(1)).thenReturn(order);
        orderService.createItem("mie", 2, 1, product);
        assertEquals(1, order.getItems().size());
        verify(itemRepository, times(1)).save(any());
    }

    @Test
    void testCreateItemThrowsException() {
        lenient().when(orderRepository.findOrderById(1)).thenReturn(order);
        lenient().when(itemRepository.save(any()))
                .thenThrow(new DataIntegrityViolationException("This item already exist"));
        Throwable exception = assertThrows(ResponseStatusException.class,
                () -> orderService.createItem("mie", 2, 1, product));
        assertEquals("400 BAD_REQUEST \"This item already exist\"", exception.getMessage());
    }

    @Test
    void testCheckProductStockValid() {
        assertTrue(orderService.checkProductStock(2, product));
    }

    @Test
    void testCheckProductStockNotValid() {
        assertFalse(orderService.checkProductStock(51, product));
    }

    @Test
    void testGetItemById() {
        lenient().when(itemRepository.findItemById(3)).thenReturn(item);
        assertEquals(item, orderService.getItemById(3));
    }

    @Test
    void testGetItemsByOrderId() {
        lenient().when(orderRepository.findOrderById(1)).thenReturn(order);
        lenient().when(itemRepository.findAllByOrder(order)).thenReturn(itemsIterable);
        assertEquals(itemsIterable, orderService.getItemsByOrderId(1));
    }

    @Test
    void testCreateOrderTransactionSuccess() {
        orderService.createOrderTransaction(walletBuyer, walletSeller, 50000);
        verify(walletService, times(2)).createTransaction(any(), anyString(), any());
    }

    @Test
    void testUpdateWalletBalanceSuccess() {
        lenient().when(mockBuyer.getWallet()).thenReturn(walletBuyer);
        lenient().when(mockSeller.getWallet()).thenReturn(walletSeller);
        orderService.updateWalletBalance(mockBuyer, mockSeller, 50000);
        verify(walletRepository, times(2)).save(any());
        assertEquals((double) 150000, walletBuyer.getBalance());
        assertEquals((double) 150000, walletSeller.getBalance());
    }

    @Test
    void testPayOrderSuccess() {
        lenient().when(mockBuyer.getWallet()).thenReturn(walletBuyer);
        lenient().when(mockSeller.getWallet()).thenReturn(walletSeller);
        Order toPay = orderService.payOrder(order);
        assertEquals("Open", toPay.getStatus());
        assertFalse(toPay.isFinished());
        assertTrue(toPay.isPaymentReceived());
        verify(orderRepository, times(1)).save(any());
    }

    // Tests when Order State is Open
    @Test
    void testConfirmOrderSuccessWhenStateIsOpen() {
        Order toConfirm = orderService.confirmOrder(order);
        assertEquals("Confirmed", toConfirm.getStatus());
        assertNotNull(toConfirm.getPaymentTime());
        assertFalse(toConfirm.isFinished());
        verify(orderRepository, times(1)).save(any());
    }

    @Test
    void testCancelOrderSuccessWhenStateIsOpen() {
        Order toCancel = orderService.cancelOrder(order);
        assertEquals("Cancelled", toCancel.getStatus());
        assertTrue(toCancel.isFinished());
        verify(orderRepository, times(1)).save(any());
    }

    @Test
    void testShipOrderFailsWhenStateIsOpen() {
        Order toShip = orderService.shipOrder(order);
        assertNotEquals("Ship", toShip.getStatus());
        assertNull(toShip.getShipTime());
        assertFalse(toShip.isFinished());
        verify(orderRepository, times(1)).save(any());
    }

    @Test
    void testDeliverOrderFailsWhenStateIsOpen() {
        Order toDeliver = orderService.shipOrder(order);
        assertNotEquals("Delivered", toDeliver.getStatus());
        assertNull(toDeliver.getCompletedTime());
        assertFalse(toDeliver.isFinished());
        verify(orderRepository, times(1)).save(any());
    }

}
